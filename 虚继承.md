派生类访问基类继承的成员

基类与派生类的成员重名的话，要在基类成员前面加作用域::

从不同的基类继承了同名成员的话，要在基类成员面前加作用域::

虚基类

 当派生类从多个基类派生，而这些基类又共同基类，则在访问此共同基类中的成员时，将产生冗余，并有可能因冗余带来不一致性 

 例：class B1:virtual public B 

 ![http://sc0.ykt.io/ue_i/20200305/1235393518416039936.png](http://sc0.ykt.io/ue_i/20200305/1235393518416039936.png) 

构造时要把直接基类的也要加入声明中

```c++
#include <iostream>
using namespace std;

class Base0 {   
public:
    Base0(int var) : var0(var) { }
    int var0;
    void fun0() { cout << "Member of Base0" << endl; }
};
class Base1: virtual public Base0 {
public: 
    Base1(int var) : Base0(var) { }
    int var1;
};
class Base2: virtual public Base0 { 
public:
    Base2(int var) : Base0(var) { }
    int var2;
};

class Derived: public Base1, public Base2 {
public:
    Derived(int var) : Base0(var), Base1(var), Base2(var) 
   { }
    int var;
    void fun() 
   { cout << "Member of Derived" << endl; }
};

int main() {    //程序主函数
    Derived d(1);
    d.var0 = 2; //直接访问虚基类的数据成员
    d.fun0();   //直接访问虚基类的函数成员
    return 0;
}
```

复制构造函数在编译器中已经默认，但是为浅复制，深复制需要自己定义，除了参数为引用外与构造函数类似，返回类类型的引用，或者参数为引用都不用复制构造函数。

​	总的来说，就是开辟匿名对象的存储空间时要开复制构造函数。

静态成员函数不可以用this指针（公用），最好用类名::作限定词（在main函数中）

通过参数访问数据成员

友元：可以访问全部的友元成员啊，逻辑上面更加方便，拿来做并列关系比较好，就挺方便的

